/*
@Time       : 2019/12/30 12:03 下午
@Author     : lei
@File       : dataResult
@Software   : GoLand
@Desc       :
*/
package computed

import (
	"encoding/json"
	"fmt"
	"github.com/gomodule/redigo/redis"
	"strings"
	"sync"
	"time"
	"vmStat/logging"
	"vmStat/utils"
	"vmStat/utils/ip2region"
)

/*
计算模块
*/
const (
	timeTableName          = "ob_stat_time"      // 时间表
	areaTableName          = "ob_stat_time_area" // 地区表
	newUserTableName       = "ob_stat_user"      // 新用户表
	retentionRateTableName = "ob_stat_retention"
	mapLength              = 100
)

var (
	logger = logging.NewConsoleLogger("debug")
	wg     sync.WaitGroup
	lock sync.Mutex
)

type dataResult struct {
	FilePath    string
	datePrefix  string // 文件时间戳
	hourPrefix  string
	dayAppidUid map[string][]interface{}
	timeResult  map[string]*TimeFields
	areaResult  map[string]*AreaFields
	newsResult  []*UserFields
	//:= make(map[string][]interface{},10)
}

func NewDataResult(filePath string) *dataResult {
	dataPrefixArray := strings.Split(filePath, ".")
	dataPrefix := dataPrefixArray[len(dataPrefixArray)-2][:8]
	hourPrefix := dataPrefixArray[len(dataPrefixArray)-2][:10]
	dayAppidUid := make(map[string][]interface{}, 10)
	var timeResult = make(map[string]*TimeFields, 100)
	var areaResult = make(map[string]*AreaFields, 100)
	return &dataResult{FilePath: filePath, datePrefix: dataPrefix, dayAppidUid: dayAppidUid, hourPrefix: hourPrefix, timeResult: timeResult, areaResult: areaResult}
}

type StatisticItem struct {
	Pv        int64 `json:"pv"`
	Uv        int64 `json:"uv"`
	PathUv    int64 `json:"path_uv"`
	AppUv     int64 `json:"app_uv"`
	PathAppUv int64 `json:"path_app_uv"`
	Ip        int64 `json:"ip"`
	AppIp     int64 `json:"app_ip"`
}

func NewStatisticItem() *StatisticItem {
	return &StatisticItem{Pv: 0, Uv: 0, PathUv: 0, AppUv: 0, PathAppUv: 0, Ip: 0, AppIp: 0}
}

// 时间表
type TimeFields struct {
	AppId string `json:"app_id"`
	Path  string `json:"path"`
	*StatisticItem
}

func NewTimeFields(appId string, path string, ) *TimeFields {
	return &TimeFields{AppId: appId, Path: path, StatisticItem: NewStatisticItem()}
}

// 地区表
type AreaFields struct {
	Country  string `json:"country"`
	Province string `json:"province"`
	City     string `json:"city"`
	*TimeFields
}

// 新用户表
type UserFields struct {
	Appid    string
	Users    int64
	AppUsers int64
}

func NewAreaFields(country string, province string, city string, appId string, path string, ) *AreaFields {
	return &AreaFields{Country: country, Province: province, City: city, TimeFields: NewTimeFields(appId, path)}
}

type AccessLog struct {
	Ip     string `json:"ip"`
	Uid    string `json:"uid"`
	Appid  string `json:"appid"`
	Credit string `json:"credit"`
	Path   string `json:"path"`
	Uuid   string `json:"uuid"`
}

func parasData(filePath string) (accessData []*AccessLog, err error) {
	data, err := utils.ReadFilesLines(filePath)
	if err != nil {
		return nil, err
	}
	//var mapResult []map[string]interface{}
	strData := strings.ReplaceAll(string(data), "\n", ",")
	strData = "[" + strData
	strData = strings.TrimRight(strData, ",")
	strData += "]"
	err = json.Unmarshal([]byte(strData), &accessData)
	if err != nil {
		fmt.Println("解析json出错")
		return nil, err
	}
	return
}

// 返回地址信息
func region(ipAddr string) *ip2region.IpInfo {
	region, err := ip2region.New("./utils/ip2region/ip2region.db")
	if err != nil {
		fmt.Println(err)
	}
	ip, err := region.BtreeSearch(ipAddr)
	return &ip
}

func (d *dataResult) Run() {
	accessData, err := parasData(d.FilePath)
	if err != nil {
		fmt.Println("序列化数据错误:", err)
		return
	}
	dataChan := make(chan *AccessLog, 10)
	// 将数据写入channel
	go func(accessData []*AccessLog, dataChan chan<- *AccessLog) {
		for _, v := range accessData {
			dataChan <- v
		}
		close(dataChan)
	}(accessData, dataChan)

	for i := 0; i < 4; i++ {
		wg.Add(1)
		go d.computed(dataChan)
	}
	wg.Wait()
	//fmt.Println(d.timeResult)

}

func (d *dataResult) computed(dataChan <-chan *AccessLog) {
	pool := utils.Pool
	redisConn := pool.Get()
	defer redisConn.Close()
	defer wg.Done()
	for v := range dataChan {
		timeAppPathKey := v.Appid + ":" + v.Path
		if _, ok := d.timeResult[timeAppPathKey]; !ok {
			lock.Lock()
			d.timeResult[timeAppPathKey] = NewTimeFields(v.Appid, v.Path)
			lock.Unlock()
		}
		key := d.datePrefix + ":UV:" + v.Uuid
		r, err := redisConn.Do("get", key)
		if err != nil {
			fmt.Println(err)
			return
		}
		if r == nil {
			lock.Lock()
			d.timeResult[timeAppPathKey].Uv++
			lock.Unlock()
		}
	}

}

func inArr(list interface{}, key interface{}) bool {
	for _, v := range list.([]string) {
		if key == v {
			return true
		}
	}
	return false
}

//dataResult 计算方法
//func (d *dataResult) Run() error {
//	// logFilePath 日志文件，格式 xxx.xxx.201912261658.log
//	if err := parasData(d.FilePath); err != nil {
//		return err
//	}
//
//	/*
//		redis记录格式
//		uv          20191129:UV:uvMap
//		path_uv     20191129:PATH:UV:path:uvMap
//		app_uv      20191129:APP:UV:appid:uid
//		path_app_uv 20191129:PATH:APP:UV:path:appid:uid
//		ip          20191129:IP:ip
//		app_ip      20191129:APP:IP:ip
//	*/
//
//	dataChan := make(chan *AccessLog, 50)
//
//	uvMap := make(map[string][2]string, mapLength)
//	pathUvMap := make(map[string][2]string, mapLength)
//	appUvMap := make(map[string][2]string, mapLength)
//	pathAppUvMap := make(map[string][2]string, mapLength)
//	ipMap := make(map[string][2]string, mapLength)
//	appIpMap := make(map[string][2]string, mapLength)
//
//	newUuid := make(map[string][]interface{}, mapLength)
//	newUid := make(map[string][]interface{}, mapLength)
//	//
//	go produceLog(AllAccessLog, dataChan)
//
//	for v := range dataChan {
//
//		timeAppPathKey := v.Appid + ":" + v.Path
//		ipInfo := region(v.Ip)
//		areaAppPathKey := v.Appid + ":" + v.Path + ":" + ipInfo.Country + ":" + ipInfo.Province + ":" + ipInfo.City
//		//
//		if _, ok := d.timeResult[timeAppPathKey]; !ok {
//			d.timeResult[timeAppPathKey] = NewTimeFields(v.Appid, v.Path)
//
//		}
//		if _, ok := d.areaResult[areaAppPathKey]; !ok {
//			d.areaResult[areaAppPathKey] = NewAreaFields(ipInfo.Country, ipInfo.Province, ipInfo.City, v.Appid, v.Path)
//		}
//
//		if _, ok := newUuid[v.Appid]; !ok {
//			newUuid[v.Appid] = make([]interface{}, 0, 100)
//			newUid[v.Appid] = make([]interface{}, 0, 100)
//		}
//
//		newUuid[v.Appid] = append(newUuid[v.Appid], v.Uuid)
//		newUid[v.Appid] = append(newUid[v.Appid], v.Uid)
//
//		d.timeResult[timeAppPathKey].Pv++
//		d.areaResult[areaAppPathKey].Pv++
//
//		// 计算每个appid下的uid
//		if _, ok := d.dayAppidUid[v.Appid]; !ok {
//			d.dayAppidUid[v.Appid] = make([]interface{}, 0, 10)
//		}
//		d.dayAppidUid[v.Appid] = append(d.dayAppidUid[v.Appid], v.Uid)
//
//		// 计算uv
//		uvKey := d.datePrefix + ":UV:" + v.Uuid
//		if _, ok := uvMap[uvKey]; !ok {
//			uvMap[uvKey] = [2]string{timeAppPathKey, areaAppPathKey}
//		}
//
//		// 计算path_uv
//		pathUvKey := d.datePrefix + ":PATH:UV:" + v.Path + ":" + v.Uuid
//		if _, ok := pathUvMap[pathUvKey]; !ok {
//			pathUvMap[pathUvKey] = [2]string{timeAppPathKey, areaAppPathKey}
//		}
//
//		// 计算app_uv
//		appUvKey := d.datePrefix + ":APP:UV:" + v.Appid + ":" + v.Uid
//		if _, ok := appUvMap[appUvKey]; !ok {
//			appUvMap[appUvKey] = [2]string{timeAppPathKey, areaAppPathKey}
//		}
//
//		// 计算path_app_uv
//		pathAppUvKey := d.datePrefix + ":PATH:APP:UV:" + v.Path + ":" + v.Appid + ":" + v.Uid
//		if _, ok := pathAppUvMap[pathAppUvKey]; !ok {
//			pathAppUvMap[pathAppUvKey] = [2]string{timeAppPathKey, areaAppPathKey}
//		}
//
//		// 计算ip
//		ipKey := d.datePrefix + ":IP:" + v.Ip
//		if _, ok := ipMap[ipKey]; !ok {
//			ipMap[ipKey] = [2]string{timeAppPathKey, areaAppPathKey}
//		}
//		// 计算app_ip
//		appIpKey := d.datePrefix + ":IP:" + v.Ip
//
//		if _, ok := appIpMap[appIpKey]; !ok {
//			appIpMap[appIpKey] = [2]string{timeAppPathKey, areaAppPathKey}
//		}
//	}
//	//var u UserFields
//
//	//for i, v := range newUuid {
//	//	uidCount, _ := redisClient.SAdd("HISTORY:UUID:"+i, v...)
//	//	uuidCount, _ := redisClient.SAdd("HISTORY:UID:"+i, newUid[i]...)
//	//	_,_ = redisClient.SAdd(d.datePrefix+":UID:"+i, v...)
//	//	u.Appid = i
//	//	u.Users = uidCount
//	//	u.AppUsers = uuidCount
//	//	d.newsResult = append(d.newsResult, &u)
//	//}
//	//for _, v := range d.newsResult {
//	//	fmt.Printf("appid:%s user:%d app_user:%d\n", v.Appid, v.Users, v.AppUsers)
//	//}
//
//	//fmt.Println(newUid)
//
//	wg.Add(6)
//	go d.resultCalculation(uvMap, "uv")
//	go d.resultCalculation(pathUvMap, "path_uv")
//	go d.resultCalculation(appUvMap, "app_uv")
//	go d.resultCalculation(pathAppUvMap, "path_app_uv")
//	go d.resultCalculation(ipMap, "ip")
//	go d.resultCalculation(appIpMap, "app_ip")
//	wg.Wait()
//
//	func() {
//		allKeys := make([]string, 0, mapLength)
//		for k, _ := range uvMap {
//			allKeys = append(allKeys, strings.Split(k, ":")[2])
//
//		}
//
//	}()
//
//	//for k, v := range d.dayAppidUid {
//	//	k = d.datePrefix + ":APPID:UID:" + k
//	//	_, _ = redisClient.SAdd(k, v...)
//	//}
//	//
//	//err := d.generateSqlFile()
//	//if err != nil{
//	//	fmt.Println("计算错误: err=", err)
//	//}
//	//d.writeResultSql()
//	return nil
//}

func (d *dataResult) timeFormat(s string) (string, error) {
	t, err := time.Parse("2006010215", s)
	if err != nil {
		fmt.Println(err)
		return "", err
	}
	return t.Format("2006-01-02 15:00:00"), nil
}

// 通过redis 查询出需要insert或update的数据
//func (c dataResult) keyClassifier(a interface{}) (insertData, updateData []interface{}, err error) {
//	redisConn := utils.Pool.Get()
//	defer redisConn.Close()
//
//	index := 0
//	switch v := a.(type) {
//	case map[string]*TimeFields:
//		//fmt.Println("map[string]*TimeFields")
//		keyData := make([]interface{}, len(v))
//		for k, _ := range v {
//			keyData[index] = c.hourPrefix + ":MYSQL:" + k
//			index++
//		}
//
//		res,err := redisConn.Do()
//
//		if res, err := redisClient.MGet(keyData...); err == nil {
//			for i, v := range res {
//				if v == nil {
//					insertData = append(insertData, keyData[i])
//				} else {
//					updateData = append(updateData, keyData[i])
//				}
//			}
//			return insertData, updateData, nil
//		} else {
//			return nil, nil, err
//		}
//
//	case map[string]*AreaFields:
//		//fmt.Println("map[string]*AreaFields")
//		keyData := make([]string, len(v))
//		for k, _ := range v {
//			keyData[index] = c.hourPrefix + ":MYSQL:" + k
//			index++
//		}
//		if res, err := redisClient.MGet(keyData...); err == nil {
//			for i, v := range res {
//				if v == nil {
//					insertData = append(insertData, keyData[i])
//				} else {
//					updateData = append(updateData, keyData[i])
//				}
//			}
//			return insertData, updateData, nil
//		} else {
//			return nil, nil, err
//		}
//	default:
//		return nil, nil, errors.New("类型错误")
//	}
//}

//generateSqlFile 生成sql文件
func (d *dataResult) writeResultSql() (err error) {
	/*
		从result 取出所有key，查询redis，判断哪些key存在于mysql记录中
		1。 取出所有key
		2。 去redis查询所有key
		3。 判断哪些key存在，将存在的key写入到update列表，不存在的key写入insert列表
	*/
	//1。 取出所有key
	timeKeys := make([]interface{}, len(d.timeResult))
	//areaKeys := make([]interface{}, len(d.areaResult))

	sqlData := make([]byte, 0, 10)
	i := 0
	for k, _ := range d.timeResult {
		// redis 存储key 为 2019112901:appid:path
		timeKeys[i] = d.hourPrefix + ":" + k
		i++
	}

	//2。 去redis查询所有key
	timeInsertChan := make(chan int, 10)
	timeUpdateChan := make(chan int, 10)

	go func(timeInsertChan, timeUpdateChan chan int) {
		redisConn := utils.Pool.Get()
		res, err := redisConn.Do("mget", timeKeys...)
		if err != nil {
			fmt.Println("Redis mget err:", err)
			return
		}
		for i, v := range res.([]interface{}) {
			if v != nil {
				timeUpdateChan <- i
			} else {
				timeInsertChan <- i
			}

		}
		close(timeInsertChan)
		close(timeUpdateChan)
	}(timeInsertChan, timeUpdateChan)

	//3. 判断哪些key存在，将存在的key写入到update列表，不存在的key写入insert列表
	datetimeField, _ := d.timeFormat(d.hourPrefix)
	for i := range timeInsertChan {
		// v != nil 说明key已经存在
		key := timeKeys[i].(string)
		sPtr := d.timeResult[strings.Join(strings.Split(key, ":")[1:], ":")]
		sql := fmt.Sprintf("INSERT INTO %s (datetime, path, appid, pv, uv, path_uv, app_uv, path_app_uv,ip,app_ip) VALUES (\"%s\",\"%s\",\"%s\",\"%d\",\"%d\",\"%d\",\"%d\",\"%d\",\"%d\",\"%d\");\n",
			timeTableName, datetimeField, sPtr.Path, sPtr.AppId, sPtr.Pv, sPtr.Uv, sPtr.PathUv, sPtr.AppUv, sPtr.PathAppUv, sPtr.Ip, sPtr.AppIp)
		sqlData = append(sqlData, []byte(sql)...)
	}
	/*
		sql := fmt.Sprintf("UPDATE  %s SET pv=pv+%d,uv=uv+%d path_uv=path_uv+%d,app_uv=app_uv+%d,path_app_uv=path_app_uv+%d,ip=ip+%d,app_ip=app_ip+%d WHERE dattetime=\"%s\" AND path=\"%s\" AND appid=\"%d\";\n",
				timeTableName, sPtr.Pv, sPtr.Uv, sPtr.PathUv, sPtr.AppUv, sPtr.PathAppUv, sPtr.Ip, sPtr.AppIp, datetimeField, sPtr.Path, sPtr.AppIp)
			sqlData = append(sqlData, []byte(sql)...)
	*/

	filePath := "./sql_files/" + d.hourPrefix + ".sql"
	if err = utils.WriteFiles(filePath, sqlData); err != nil {
		fmt.Println("写入sql文件错误:", err)
		return err
	}

	return
}

//generateSqlFile 生成sql文件
//func (c dataResult) generateSqlFile() (err error) {
//
//	sqlData := make([]byte, 0, 100)
//
//
//	timeInsertData, timeUpdateData, _ := c.keyClassifier(c.timeResult)
//	areaInsertData, areaUpdateData, _ := c.keyClassifier(c.areaResult)
//
//	if len(timeInsertData) > 0 {
//		_, err := redisClient.MSet(timeInsertData...)
//		if err != nil {
//			fmt.Println(err)
//		}
//
//	}
//	if len(areaInsertData) > 0 {
//		redisClient.MSet(areaInsertData...)
//	}
//
//	datetimeField, _ := c.timeFormat(c.hourPrefix)
//	for _, i := range timeInsertData {
//		key := strings.Split(i.(string), ":")
//		sPtr := c.timeResult[strings.Join(key[2:], ":")]
//		sql := fmt.Sprintf("INSERT INTO %s (datetime, path, appid, pv, uv, path_uv, app_uv, path_app_uv,ip,app_ip) VALUES (\"%s\",\"%s\",\"%s\",\"%d\",\"%d\",\"%d\",\"%d\",\"%d\",\"%d\",\"%d\");\n",
//			timeTableName, datetimeField, sPtr.Path, sPtr.AppId, sPtr.Pv, sPtr.Uv, sPtr.PathUv, sPtr.AppUv, sPtr.PathAppUv, sPtr.Ip, sPtr.AppIp)
//		sqlData = append(sqlData, []byte(sql)...)
//	}
//
//	for _, i := range timeUpdateData {
//		key := strings.Split(i.(string), ":")
//		sPtr := c.timeResult[strings.Join(key[2:], ":")]
//		sql := fmt.Sprintf("UPDATE  %s SET pv=pv+%d,uv=uv+%d path_uv=path_uv+%d,app_uv=app_uv+%d,path_app_uv=path_app_uv+%d,ip=ip+%d,app_ip=app_ip+%d WHERE dattetime=\"%s\" AND path=\"%s\" AND appid=\"%d\";\n",
//			timeTableName, sPtr.Pv, sPtr.Uv, sPtr.PathUv, sPtr.AppUv, sPtr.PathAppUv, sPtr.Ip, sPtr.AppIp, datetimeField, sPtr.Path, sPtr.AppIp)
//		sqlData = append(sqlData, []byte(sql)...)
//	}
//
//	for _, i := range areaInsertData {
//		key := strings.Split(i.(string), ":")
//		sPtr := c.areaResult[strings.Join(key[2:], ":")]
//		sql := fmt.Sprintf("INSERT INTO %s (datetime, country,province,city,path, appid, pv, uv, path_uv, app_uv, path_app_uv,ip,app_ip) VALUES (\"%s\",\"%s\",\"%s\",\"%s\",\"%s\",\"%s\",\"%d\",\"%d\",\"%d\",\"%d\",\"%d\",\"%d\",\"%d\");\n",
//			timeTableName, datetimeField, sPtr.Country, sPtr.Province, sPtr.City,
//			sPtr.Path, sPtr.AppId, sPtr.Pv, sPtr.Uv, sPtr.PathUv, sPtr.AppUv, sPtr.PathAppUv, sPtr.Ip, sPtr.AppIp)
//		sqlData = append(sqlData, []byte(sql)...)
//
//		sqlData = append(sqlData, []byte(sql)...)
//	}
//	for _, i := range areaUpdateData {
//		key := strings.Split(i.(string), ":")
//		sPtr := c.areaResult[strings.Join(key[2:], ":")]
//		sql := fmt.Sprintf("UPDATE  %s SET pv=pv+%d,uv=uv+%d path_uv=path_uv+%d,app_uv=app_uv+%d,path_app_uv=path_app_uv+%d,ip=ip+%d,app_ip=app_ip+%d WHERE dattetime=\"%s\" AND path=\"%s\" AND appid=\"%d\" AND country=\"%s\" AND province=\"%s\" AND city=\"%s\";\n",
//			timeTableName, sPtr.Pv, sPtr.Uv, sPtr.PathUv, sPtr.AppUv, sPtr.PathAppUv, sPtr.Ip, sPtr.AppIp, datetimeField, sPtr.Path, sPtr.AppIp, sPtr.Country, sPtr.Province, sPtr.City)
//		sqlData = append(sqlData, []byte(sql)...)
//	}
//
//	filePath := "./sql_files/" + c.hourPrefix + ".sql"
//
//	if err = utils.WriteFiles(filePath, sqlData); err != nil {
//		return
//	}
//	return
//}

//计算最终结果
func (d *dataResult) resultCalculation(kindMap map[string][2]string, kind string) {
	defer wg.Done()
	redisConn := utils.Pool.Get()
	defer redisConn.Close()

	//newKeysList := make([]interface{}, 0, mapLength/2) // 新key切片,随后将新key存入redis中

	//fmt.Println(kind, "goroutine run")
	keysList := make([]interface{}, len(kindMap)) // 所有key 切片
	keyIndex := 0                                 // 初始化keysList下标索引
	for key, _ := range kindMap {
		keysList[keyIndex] = key
		keyIndex++
	}
	//// 查询redis，确认哪些key是新的
	if len(keysList) == 0 {
		return
	}
	//

	//res, err := redisClient.MGet(keysList...)

	res, err := redis.Strings(redisConn.Do("MGet", keysList...))
	if err != nil {
		logger.Debug("redis mset err:%v\n", err)
	}
	fmt.Println(kind, len(res))
	////
	//for i, v := range res.([]interface{}) {
	//	if v == nil {
	//		key := keysList[i].(string)
	//		newKeysList = append(newKeysList, []interface{}{key, 1}...)
	//
	//		switch kind {
	//		case "uv":
	//			d.timeResult[kindMap[key][0]].Uv++
	//			d.areaResult[kindMap[key][1]].Uv++
	//		case "path_uv":
	//			d.timeResult[kindMap[key][0]].PathUv++
	//			d.areaResult[kindMap[key][1]].PathUv++
	//		case "app_uv":
	//			d.timeResult[kindMap[key][0]].AppUv++
	//			d.areaResult[kindMap[key][1]].AppUv++
	//		case "path_app_uv":
	//			d.timeResult[kindMap[key][0]].PathAppUv++
	//			d.areaResult[kindMap[key][1]].PathAppUv++
	//		case "ip":
	//			d.timeResult[kindMap[key][0]].Ip++
	//			d.areaResult[kindMap[key][1]].Ip++
	//		case "app_ip":
	//			d.timeResult[kindMap[key][0]].AppIp++
	//			d.areaResult[kindMap[key][1]].AppIp++
	//		}
	//	}
	//}
	//if len(newKeysList) == 0 {
	//	return
	//}
	////将不存在的key写入redis
	//res, err = redisConn.Do("MSet", newKeysList...)
	//if err != nil {
	//	fmt.Println("Redis MSet err:", err)
	//	return
	//}
}
